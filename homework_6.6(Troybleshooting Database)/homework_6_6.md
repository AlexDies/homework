## Домашнее задание к занятию "6.6. Troubleshooting"
___
**Задача 1**

Перед выполнением задания ознакомьтесь с документацией по администрированию MongoDB.

Пользователь (разработчик) написал в канал поддержки, что у него уже 3 минуты происходит CRUD операция в MongoDB и её нужно прервать.

Вы как инженер поддержки решили произвести данную операцию:

- напишите список операций, которые вы будете производить для остановки запроса пользователя
- предложите вариант решения проблемы с долгими (зависающими) запросами в MongoDB
___
**Выполнение ДЗ:**

1. Список операций для остановки запросов пользователя:

Можно использовать метод `db.killOp(<opId>)` с указанием операции. Для этого первоначально необходимо узнать этот идентификатор операции с помощью
использования агрегации `$currentOp` в формате:
    
        db.aggregate( [
           { $currentOp : { allUsers: true } },
           { $match : <filter condition> } // Optional.  Specify the condition to find the op.
        ] )

Что вернет нам список opId, который можно использовать в методе `db.killOp(<opId>)`

2. Вариант решения проблемы с долгими(зависающими) запросами в MongoDB:

В зависимости от того, с чем связана проблема. Долгие запросы или зависания могут быть по нескольким причинам:
- Большое количество подключений может влиять на обработку запросов БД 
  
  (_В таком случае необходимо масштабировать это количество - увеличить количество шард в кластере или увеличить параметр `maxIncomingConnections `в конфигурации или изменить ограничения системы `ulimit`_)
- Нехватка ёмкости БД 
  
  (_В таком случае, необходимо увеличить ёмкость диска_)
- Блокировка производительности из-за системы блокировки, так как часть запросов попала в блокировку 
  
  (_Проблема может быть в неэффективном/неправильном использовании индексов или же неоптимальной созданной схемы,
  а также может быть в самой структуре запрос или же недостатка ОЗУ, что ведет к чтению с диска_)

Также в поиске и анализе проблемы можно использовать метод `.explain("executionStats")` для конкретного запроса, который покажет статистику запроса и вызов
`db.currentOp({"secs_running":{$gte:}})` для просмотра проблемных запросов.

Дополнительно рекомендуется включить мониторинг (Free monitoring) поставляемый вместе с MongoDB с помощью команды `db.enableFreeMonitoring()`, что позволит отслеживать нагрузку на сервер, утилизацию диска, время операций.
  
___
**Задача 2**

Перед выполнением задания познакомьтесь с документацией по Redis latency troobleshooting.

Вы запустили инстанс Redis для использования совместно с сервисом, который использует механизм TTL. Причем отношение количества записанных key-value значений к количеству истёкших значений есть величина постоянная и увеличивается пропорционально количеству реплик сервиса.

При масштабировании сервиса до N реплик вы увидели, что:

- сначала рост отношения записанных значений к истекшим
- Redis блокирует операции записи

Как вы думаете, в чем может быть проблема?
___
**Выполнение ДЗ:**

Необходимо выполнить и проверить следующее:
- Проверить блокировку slow команд с помощью `redis- cli SLOWLOG GET N `. 

- Отключить huge page на уровне ядра системы
  
  (_Подать команду `echo never > /sys/kernel/mm/transparent_hugepage/enabled`, что отключи использование huge page_)

- Возможно присутсвует внутренняя задержка VM
  
  (_В таком случае, необходимо измерить задержку с помощью команды` redis-cli --intrinsic-latency 100 `Каким-либо образом исключить эту задержку не получится из-за ограничений гипервизора в ВМ_)

- Сетева задержка стека TCP/IP
  
  (В этом случае, можно воспользоваться unix советом, если клиент находится там же где и сервер, использовать агрегированные команды MSET, MGET, посмотреть в сторону оптимизации сети(при вовзможности))
___
**Задача 3**

Перед выполнением задания познакомьтесь с документацией по Common Mysql errors.

Вы подняли базу данных MySQL для использования в гис-системе. При росте количества записей, в таблицах базы, пользователи начали жаловаться на ошибки вида:

    InterfaceError: (InterfaceError) 2013: Lost connection to MySQL server during query u'SELECT..... '

Как вы думаете, почему это начало происходить и как локализовать проблему?

Какие пути решения данной проблемы вы можете предложить?
___
**Выполнение ДЗ:**

Варианты могут быть следующие:
- Когда большое количество запросов передаются "как одно целое" 
   
  (_В таком случае, необходимо изменить значение параметра `net_read_timeout` с 30 до нужного_)
- В случае, если прошел большой таймаут, например, из-за нестабильного соединения
  
  (_Тут можно увеличить значение параметра `connect_timeout` на большее значение. Командой `SHOW GLOBAL STATUS LIKE 'Aborted_connects'` можно посмотреть значение и если оно увеличивается с возникновением ошибки, то увеличение таймаута должно помочь_)
- Возможно проблема связана с большим значением BLOB, превышающий параметр `max_allowed_packet`
  
  (_Необходимо будет увеличить значение параметра `max_allowed_packet` как на сервере, так и на клиенте_)
  
___
**Задача 4**

Перед выполнением задания ознакомтесь со статьей Common PostgreSQL errors из блога Percona.

Вы решили перевести гис-систему из задачи 3 на PostgreSQL, так как прочитали в документации, что эта СУБД работает с большим объемом данных лучше, чем MySQL.

После запуска пользователи начали жаловаться, что СУБД время от времени становится недоступной. В dmesg вы видите, что:

`postmaster invoked oom-killer`

Как вы думаете, что происходит?

Как бы вы решили данную проблему?

___
**Выполнение ДЗ:**

OOM-Killer завершает процесс PostgreSQL, так как не хватает памяти и "спасает систему" этим.

Для решения данной ситуации, можно изменить значение `vm.overcommit_memory` равным 2 (работать без overcommit), что снизит вероятность того, что OOM-Killer завершит процесс PostgreSQL.
Но самым лучшим методом решения будет конечно же увеличение оперативной памяти.


