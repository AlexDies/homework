## Домашняя работа к занятию "4.1. Командная оболочка Bash: Практические навыки"
---

1. __Есть скрипт:__

	   a=1
	   b=2
	   c=a+b
	   e=$(($a+$b))
    
__Какие значения переменным c,d,e будут присвоены? Почему?__

Значение переменной С = a+b так как не объявлено, что обращение идет именно к переменным $a и $b, значение воспринимается как строка

Значение переменной D = 1+2 обращение идет именно к переменным $a и $b, но воспринимается как строка

Значение переменной E = 3 обращение идет к переменным $a и $b и происходит операция сложения, выделенная двойными скобками $(( )).

---
__2.На нашем локальном сервере упал сервис и мы написали скрипт, который постоянно проверяет его доступность, записывая дату проверок до тех пор, пока сервис не станет доступным. В скрипте допущена ошибка, из-за которой выполнение не может завершиться, при этом место на Жёстком Диске постоянно уменьшается. Что необходимо сделать, чтобы его исправить:__

	#!/bin/bash
	while ((1==1))
	do
	curl -I http://localhost:80
	 if (("$?" != 0))
	  then
	   date >> curl.log
	  else
	   break
	  fi
	done
Внесены исправления. Добавлена скоба в while и добавлена команда break в операторе if - else для выхода из цикла.

---
__3.Необходимо написать скрипт, который проверяет доступность трёх IP: 192.168.0.1, 173.194.222.113, 87.250.250.242 по 80 порту и записывает результат в файл log. 
Проверять доступность необходимо пять раз для каждого узла.__

Скрипт выглядит следующим образом:

	#!/bin/bash
	ip=(192.168.0.1 173.194.222.113 87.250.250.242)
	for i in ${ip[@]}
	do
	x=0
	while ((x!=5))
	    do
	    curl -I --connect-time 2 http://$i:80>/dev/null
	       if (($? !=0))
	          then
	          let "x+=1"
	          echo `date` " IP "$i" Not Avalible" >> log
	          else
	          echo `date` " IP "$i" Avalible" >> log
	          let "x+=1"
	       fi
	done
	done
Результат вывода файла log получился следующий:

	Sat 29 May 2021 11:01:22 AM UTC  IP 192.168.0.1 Not Avalible
	Sat 29 May 2021 11:01:24 AM UTC  IP 192.168.0.1 Not Avalible
	Sat 29 May 2021 11:01:26 AM UTC  IP 192.168.0.1 Not Avalible
	Sat 29 May 2021 11:01:28 AM UTC  IP 192.168.0.1 Not Avalible
	Sat 29 May 2021 11:01:30 AM UTC  IP 192.168.0.1 Not Avalible
	Sat 29 May 2021 11:01:30 AM UTC  IP 173.194.222.113 Avalible
	Sat 29 May 2021 11:01:31 AM UTC  IP 173.194.222.113 Avalible
	Sat 29 May 2021 11:01:31 AM UTC  IP 173.194.222.113 Avalible
	Sat 29 May 2021 11:01:31 AM UTC  IP 173.194.222.113 Avalible
	Sat 29 May 2021 11:01:31 AM UTC  IP 173.194.222.113 Avalible
	Sat 29 May 2021 11:01:31 AM UTC  IP 87.250.250.242 Avalible
	Sat 29 May 2021 11:01:31 AM UTC  IP 87.250.250.242 Avalible
	Sat 29 May 2021 11:01:31 AM UTC  IP 87.250.250.242 Avalible
	Sat 29 May 2021 11:01:31 AM UTC  IP 87.250.250.242 Avalible
	Sat 29 May 2021 11:01:31 AM UTC  IP 87.250.250.242 Avalible

---
__4.Необходимо дописать скрипт из предыдущего задания так, чтобы он выполнялся до тех пор, пока один из узлов не окажется недоступным. 
Если любой из узлов недоступен - IP этого узла пишется в файл error, скрипт прерывается.__

	#!/bin/bash
	ip=(173.194.222.113 87.250.250.242 192.168.0.1)
	while ((1==1))
	do
	for i in ${ip[@]}
	do
	sleep 2
	curl -I --connect-time 2 http://$i:80>/dev/null
	       if (($?!=0))
		  then
		  echo `date` " IP "$i" Not Avalible" >> error
		  break 2
	       fi
	done
	done
Результат вывода в файл error:

	Sat 29 May 2021 11:06:09 AM UTC  IP 192.168.0.1 Not Avalible

__P.S. Вопросы:__
- В данном задании использовал break 2 для выхода из цикла for. Я так понял, это один из варианто реализации (он часто применим в реалиях или у такого метода есть минусы?). 
- Но также можно было бы задать булевую переменную False и поднимать её значение в True в цикле if где идёт проверка curl. И далее, сделать ещё один цикл if но с проверкой данной переменной - если она стала True, то делать break из цикла For. Правильно ли я всё понял? 
- Есть ещё какие-либо варианты реализации более проще?

---
__ДОПОЛНИТЕЛЬНОЕ ЗАДАНИЕ. Мы хотим, чтобы у нас были красивые сообщения для коммитов в репозиторий. Для этого нужно написать локальный хук для git, который будет проверять, что сообщение в коммите содержит код текущего задания в квадратных скобках и количество символов в сообщении не превышает 30. Пример сообщения: [04-script-01-bash] сломал хук.__

Написал следующий скрипт в bash:

	#!/bin/bash
	number=30
	len=$(echo -n $1|wc -m)
	if [[ $len -gt $number ]]
	  then
	  echo "Количество символов не должно превышать 30"
	  exit 1
	elif ! echo $1 | grep -qE '^(04-script-[0-9][0-9]-[a-z])';
	  then
	  echo "Наименование коммита должно быть в формате [04-script-XX-XX]"
	  exit 1
	fi
Проверил, запуская ./commit xxxx - работает.

Но когда загрузил скрипт как хук в .git/hooks/commit-msg данный скрипт работал неверно. Методом гугления и отладки получилось следующее:

	#!/bin/bash
	number=30
	len=$(cat $1|wc -m)
	if [[ $len -gt $number ]]
	  then
	  echo "Количество символов не должно превышать 30"
	  exit 1
	elif ! grep -qE '^(04-script-[0-9][0-9]-[a-z])' $1;
	  then
	  echo "Наименование коммита должно быть в формате [04-script-XX-XX]"
	  exit 1
	fi

Данный хук уже начал работать как нужно при коммите.

Когда неверно залдана длина:
	
	$ git commit -m "04-script-01-asddddddddddddddds"
	Количество символов не должно превышать 30

Когда неверно задан формат:

	$ git commit -m "04-script-2332323323223"
	Наименование коммита должно быть в формате [04-script-XX-XX]

Корретное наименование:

	$ git commit -m "04-script-01-bash"
	[main 61ff2b4] 04-script-01-bash
	 2 files changed, 74 insertions(+), 1 deletion(-)
	 create mode 100644 homework_4.1.md

__P.S.Отсюда возникли вопросы:__
- Почему при использовании echo -n $1|wc -m в хуке, подсчет происходит неверный? И показывает всегда статичную величину, независимо от того как назван коммит. Получается не всегда можно использовать echo в git хуках?
- Аналогичным образом получилось и с ! echo $1 | grep -qE '^(04-script-[0-9][0-9]-[a-z])'. Пришлось "подсунуть" переменную $1 сразу к команде grep -qE. В bash обращение к переменной напрямую в формате: grep -qE ...... $1 выдает ошибку, что такого файла нет. То есть можно сказать, что переменная в хуке git представлена как файл, раз grep её принял? 
- Как правильнее в таком случае можно было бы считать строчки? Использовал cat $1 |wc -m, так как echo нельзя. Подскажите, какие-то ещё варианты есть?
